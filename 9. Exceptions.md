# Исключения
Исключение – ошибка, которую можно предусмотреть зарание.

Обработка исключений – механизм языков программирования, предназначенный для описания реакции программы на ошибки во время выполнения, которые могут возникнуть при выполнении программы и приводят к невозможности (бессмысленности) дальнейшей отработки программой её базового алгоритма.

## Обработка исключений
В python для обработки исключений предусмотрена конструкция `try except else finally`.

Блок `try` позволяет проверить блок кода на наличие ошибок.

Блок `except` позволяет обработать ошибку.

Блок `else` позволяет выполнять код при отсутствии ошибок.

Блок `finally` позволяет выполнять код независимо от результата блоков `try-` и `except`.

Когда возникает ошибка или исключение, Python обычно останавливается и генерирует сообщение об ошибке:
```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
```

Обработка данной ошибки:
```python
try:  
	print(x)  
except:  
	print("Произошла ошибка")
```

Поскольку блок `try` вызывает ошибку, будет выполнен блок `except`.

## Обработка множества ошибок
Можно определить не ограниченое количество блоков исключений:
```python
try:  
	print(x)  
except NameError:  
	print("Ошибка названия переменной")  
except:  
	print("Что-то пошло не так")
```

## Блок `Else`
Можно использовать ключевое слово `else` для определения блока кода, который будет выполняться, если ошибок не возникло:
```python
try:  
	print("Hello")  
except:  
	print("Что-то пошло не так")  
else:  
	print("Все норм")
```

## Блок `Finally`
```python
try:  
	print(x)  
except:  
	print("Что-то пошло не так")  
finally:  
	print("'try except' Закончился")
```

Это может быть полезно для закрытия объектов и очистки ресурсов:
```python
try:  
	f = open("demofile.txt")  
	try:  
		f.write("Lorum Ipsum")  
	except:  
		print("Что-то пошло не так при записи в файл")  
	finally:  
		f.close()  
except:  
	print("Что-то пошло не так при открытии файла")
```

## Вызов исключения
Если нужно, есть возможность генерировать исключение.
Чтобы сгенерировать (или вызвать) исключение, необходимо использовать ключевое слово `raise`:
```python
x = -1  
  
if x < 0:  
	raise Exception("Нельзя делить на ноль")
```

Можно  определить, какую ошибку вызывать и какой текст выводить пользователю:
```python
x = "hello"  
  
if not type(x) is int:  
	raise TypeError("Вводить можно только целые числа")
```

## Исключения как объекты
Есть возможность определять собственные исключения, создавая новый класс. 
Этот класс исключений должен быть прямо или косвенно производным от встроенного класса исключений. Большинство встроенных исключений также являются производными от этого класса.

**Рекомендуется использовать только те исключения, что наследованы от класса Exception. 
Также не рекомендуется использовать "голый `exception`".**

Перечень встроенных исключений:
-   **BaseException** - базовое исключение, от которого берут начало все остальные.
    -   **SystemExit** - исключение, порождаемое функцией sys.exit при выходе из программы.
    -   **KeyboardInterrupt** - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
    -   **GeneratorExit** - порождается при вызове метода close объекта generator.
    -   **Exception** - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
        -   **StopIteration** - порождается встроенной фунеции next, если в итераторе больше нет элементов.
        -   **ArithmeticError** - арифметическая ошибка.
            -   **FloatingPointError** - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
            -   **OverflowError** - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
            -   **ZeroDivisionError** - деление на ноль.
        -   **AssertionError** - выражение в функции assert ложно.
        -   **AttributeError** - объект не имеет данного атрибута (значения или метода).
        -   **BufferError** - операция, связанная с буфером, не может быть выполнена.
        -   **EOFError** - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
        -   **ImportError** - не удалось импортирование модуля или его атрибута.
        -   **LookupError** - некорректный индекс или ключ.
            -   **IndexError** - индекс не входит в диапазон элементов.
            -   **KeyError** - несуществующий ключ (в словаре, множестве или другом объекте).
        -   **MemoryError** - недостаточно памяти.
        -   **NameError** - не найдено переменной с таким именем.
            -   **UnboundLocalError** - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
        -   **OSError** - ошибка, связанная с системой.
            -   **BlockingIOError**
            -   **ChildProcessError** - неудача при операции с дочерним процессом.
            -   **ConnectionError** - базовый класс для исключений, связанных с подключениями.
                -   **BrokenPipeError**
                -   **ConnectionAbortedError**
                -   **ConnectionRefusedError**
                -   **ConnectionResetError**
            -   **FileExistsError** - попытка создания файла или директории, которая уже существует.
            -   **FileNotFoundError** - файл или директория не существует.
            -   **InterruptedError** - системный вызов прерван входящим сигналом.
            -   **IsADirectoryError** - ожидался файл, но это директория.
            -   **NotADirectoryError** - ожидалась директория, но это файл.
            -   **PermissionError** - не хватает прав доступа.
            -   **ProcessLookupError** - указанного процесса не существует.
            -   **TimeoutError** - закончилось время ожидания.
        -   **ReferenceError** - попытка доступа к атрибуту со слабой ссылкой.
        -   **RuntimeError** - возникает, когда исключение не попадает ни под одну из других категорий.
        -   **NotImplementedError** - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
        -   **SyntaxError** - синтаксическая ошибка.
            -   **IndentationError** - неправильные отступы.
                -   **TabError** - смешивание в отступах табуляции и пробелов.
        -   **SystemError** - внутренняя ошибка.
        -   **TypeError** - операция применена к объекту несоответствующего типа.
        -   **ValueError** - функция получает аргумент правильного типа, но некорректного значения.
        -   **UnicodeError** - ошибка, связанная с кодированием / раскодированием unicode в строках.
            -   **UnicodeEncodeError** - исключение, связанное с кодированием unicode.
            -   **UnicodeDecodeError** - исключение, связанное с декодированием unicode.
            -   **UnicodeTranslateError** - исключение, связанное с переводом unicode.
        -   **Warning** - предупреждение.


## Создание пользовательских исключений
В Python пользователи могут определять собственные исключения, создавая новый класс. 

Этот класс исключений должен быть прямо или косвенно производным от встроенного класса исключений. Большинство встроенных исключений также являются производными от этого класса:
```python
class CustomError(Exception):
     pass

raise CustomError

raise CustomError("Ошибка")
```

Класс ошибки можно настроить:
```python
class SalaryNotInRangeError(Exception):
	"""
	Ошибка, возникающая при вводе зарплаты
	
	Attributes:
		salary -- запрлата, количество которой выводит ошибку
		message -- объяснения ошибки
	"""
    def __init__(self, salary, message="Зарплата больше чем 15000 и меньше чем 5000"):
        self.salary = salary
        self.message = message
        super().__init__(self.message)


salary = int(input("Введите размер зарплаты: "))
if not 5000 < salary < 15000:
    raise SalaryNotInRangeError(salary)
```

Вывод:
```
Enter salary amount: 2000
Traceback (most recent call last):
  File "<string>", line 17, in <module>
    raise SalaryNotInRangeError(salary)
__main__.SalaryNotInRangeError: Зарплата больше чем 15000 и меньше чем 5000
```

 Также можно перегрузть магический метод `__str__()`:
 
 ```python
class SalaryNotInRangeError(Exception):
    """
    Ошибка, возникающая при вводе зарплаты

    Attributes:
        salary -- запрлата, количество которой выводит ошибку
        message -- объяснения ошибки
    """
    def __init__(self, salary, message="Зарплата больше чем 15000 и меньше чем 5000"):
        self.salary = salary
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return f'{self.salary} -> {self.message}'


salary = int(input("Введите размер зарплаты: "))
if not 5000 < salary < 15000:
    raise SalaryNotInRangeError(salary)
```

Вывод:
```
Traceback (most recent call last):
  File "C:\Users\Denis\Desktop\test.py", line 20, in <module>
    raise SalaryNotInRangeError(salary)
__main__.SalaryNotInRangeError: 21 -> Зарплата больше чем 15000 и меньше чем 5000
```