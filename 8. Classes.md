# Классы
Класс — в *объектно-ориентированном программировании*, представляет собой шаблон для создания **объектов**, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.

Класс подобен «чертежу» для создания объектов.

Всё в Python **является объектами**. Это означает, что каждый объект имеет метод и значение по той причине.

Python — это объектно-ориентированный язык программирования.

Например:

```python
test = "string"
print(dir(test))
```

В примере мы видим строку, присвоенную переменной `test`. С помощью функции `dir()`, можем посмотреть перечень методов, в даном случае их *71*. 

## Создание класса

Чтобы создать класс, необходимо использовать ключевое слово `class`:
```python
class MyClass:  
	x = 5
```

После объявления "чертежа", можем создать *экземпляр* класса:
```python
p1 = MyClass()  
print(p1.x)
```

>Название класса пишется в `CamelCase`

## Метод `__init__()`
Приведенный выше пример представляет собой класс и объект в простейшей форме и не очень полезны.

Все классы имеют метод `__init__()` которая всегда выполняется при инициализации класса.

Метод `__init__()` необходим для присвоения значений свойств объекта или других операций, которые необходимо выполнить при создании объекта:

```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age  
  
p1 = Person("John", 36)  
  
print(p1.name)  
print(p1.age)
```

>Функция __init__() вызывается автоматически каждый раз, когда класс используется для создания нового объекта.

## Методы
Метод в объектно-ориентированном программировании — это функция, принадлежащая какому-то классу или объекту.

Метод объвляется с помощью ключевого слова `def`, а вызывается через точку.

Зачастую метод обрабатывает информацию, что хранится в объекте. Если метод такую информацию не обрабатывает, он называется статическим.

Создание метода для класса `Person`:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age  
  
	def myfunc(self):  
 		print(f"Hello my name is {self.name}")  
  
p1 = Person("John", 36)  
p1.myfunc()
```



## Свойство `self`
Параметр `self` является ссылкой на текущий экземпляр класса и используется для доступа к свойствам и методам, принадлежащим классу.

Его не обязательно называть `self`, но он должен быть первым параметром любого метода в классе:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age  
  
	def myfunc(self):  
 		print(f"Hello my name is {self.name}")  
  
p1 = Person("John", 36)  
p1.myfunc()
```

## Свойства класса
Свойство — способ доступа к внутреннему состоянию объекта, имитирующий переменную. Обращение к свойству объекта, как и метод, происходит с помощью точки.

Можно поменять значение свойства класса:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age 

p1 = Person("John", 36) 
p1.age = 40
```

## Выражение `pass`
Определения класса не могут быть *пустыми*, но если необходимо объявить класс пустым, можно использовать `pass`:
```python
class Person:  
	pass
```

## Наследование
Наследование — концепция объектно-ориентированного программирования, согласно которой один тип данных может наследовать данные и функциональность некоторого существующего другого типа, способствуя повторному использованию компонентов программного обеспечения.

Все классы наследую от базового класса `object`:
```python
class Test:
	pass


dir(Test())
```

Класс, который наследует от `Person`:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age  
  
	def myfunc(self):  
 		print(f"Hello my name is {self.name}")  

class Student(Person):
	def myfunc(self):  
 		print(f"Hello I am a student and my name is {self.name}") 
```

В примере выше мы унаследовали класс `Person`, и класс `Student` будет иметь такие же свойства и методы, которые есть в `Person`. Также был перезаписан метод `myfunc()`. 

Такое переопределение называется **перезагрузкой** метода.

## Полиморфизм
Полиморфизм – возможность обрабатывать разные типы данных принадлежащих к разным классам, с помощью одной функции или метода:

```python
class Test:
	pass


dir(Test())
```

Класс, который наследует от `Person`:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age  
  
	def myfunc(self):  
 		print(f"Hello my name is {self.name}")  

class Student(Person):
	def myfunc(self):  
 		print(f"Hello I am a student and my name is {self.name}") 
```

## Инкапсуляция
Инкапсуляция — размещение в одном классе свойств и методов, которые работают внутри класса, обеспечивает механизм сокрытия, позволяющий разграничивать доступ к различным частям класса.

Например, вместо прямого переназначения свойства класса `Person` `name`, можно создать метод, что меняет имя, а также его возвращает:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age
	
	def get_name(self):
		return self.name
		
	def set_name(self, new_name):
		self.name = new_name
		return self.get_name()

	
p1 = Person("John", 36) 
p1.set_name("Jason")
```

## Магические методы
Магические методы – методы, обрамлены двойным нижним подчеркиванием, наследуются от базового класса `object`.

С помощью магических методов, можно использовать логические, арифметические и другие встроенные операторы языка.

[Перечень магических методов](https://www.tutorialsteacher.com/python/magic-methods-in-python)

Метод `__init__()` используется при создании экземпляра класса.

Перезагрузка метода `__str__()`, что используется для вывода объекта на экран:
```python
class Person:  
	def __init__(self, name, age):  
		self.name = name  
		self.age = age
	
	def __str__(self):
		return self.name
	
	
p1 = Person("John", 36)
print(p1)
```

Перезагрузка метода `__eq__()`, что используется при сравнении *двух* экземпляров класса между собой:
```python
class Person:  
    def __init__(self, name, age):  
        self.name = name  
        self.age = age  
  
    def __eq__(self, other):  
        return self.name == other.name  
  
  
p1 = Person("John", 36)  
p2 = Person("John", 20)  
  
print(p1 == p2)
```

Для этого, мы используем параметры `self` и `other`, где `other` – другой экземпляр класса. 